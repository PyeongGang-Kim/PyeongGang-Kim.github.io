[ { "title": "5650. 핀볼 게임", "url": "/posts/5650-%ED%95%80%EB%B3%BC-%EA%B2%8C%EC%9E%84/", "categories": "SW Certificate, 모의 SW 역량테스트", "tags": "역량테스트", "date": "2022-08-22 00:11:00 +0900", "snippet": "5650. [모의 SW 역량테스트] 핀볼 게임문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRF8s6ezEDFAUo강의 링크: https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVvlSPbKAAHw5UPa&amp;subjectId=AWXCL2i6IfgDFAUo문제 분석 11가지의 블록 타입이 존재하며 이 블록과 만났을 경우 핀볼의 위치나 진행 방향이 바뀌게 된다. 벽이나 블록에 부딪히면 점수를 얻는다. 핀볼이 블랙홀과 만나거나 처음 위치로 돌아오면 게임이 종료된다. 모든 위치와 방향에서 시작해서 점수를 계산한 변은 100이고 한번 이동을 시작하면 똑같은 위치에 최대 네가지 방향으로 존재할 수 있을 것(같은 위치를 같은 방향으로 지나갈 경우 종료가 될 수 없음)이므로 한번 이동에 100 * 100 * 4 = 40000번의 이동이 있을 수 있다. 하지만 현실적으로 모든 위치를 모든 방향으로 지나갈 수는 없다. 실제로는 이 횟수보다 수십분의 1 만큼의 이동도 일어나지 않을 것이다. 넉넉하게 매 시도마다 1000번 정도의 이동이 이루어진다고 가정한다.마찬가지로 모든 위치에서 모든 방향으로 테스트를 해 보아야 하므로 40000번 핀볼을 발사시켜야 한다.총 1000 * 40000 = 4천만번의 계산을 하게 된다. 제한시간이 C 기준 3초(약 3억번 정도의 계산)이므로 충분히 모든 경우에 대해서 확인해볼 수 있다.코드 및 설명벽에 부딪히면 튕겨나와야 하므로 입력받은 맵 주변으로 5번 블록으로 둘러싸 주면 벽에 대한 예외 처리를 할 필요가 없어 편리해진다.핀볼의 상태는 현재 위치, 진행 방향 두가지를 가지고 있으면 된다.웜홀을 만나면 다른 웜홀 위치로 이동시켜 준다.각 블록 타입에 따라서 어떤 진행방향으로 만났을 때 방향을 어떻게 바꿔 줘야 하는지 미리 정의해 둔다.def solve(): \"\"\" 블록이 없는 모든 위치에서 네가지 방향으로 핀볼을 쏴 본 후 점수를 갱신한다. \"\"\" maxscore = 0 for j in range(1, N+1): for i in range(1, N+1): if not nl[j][i]: for d in range(4): tmp = shoot(i, j, d) if tmp &gt; maxscore: maxscore = tmp return maxscoredef shoot(i, j, d): \"\"\" 핀볼을 i, j 위치에서 d 방향으로 발사했을 경우의 점수를 반환하는 함수 \"\"\" score = 0 x = i + dr[d][0] y = j + dr[d][1] # 처음 위치나 블랙홀을 만나기 전까지 계속해서 진행 while 1: # 현재 위치를 확인한다. tmp = nl[y][x] # 시작지점이면 종료. if x == i and y == j: return score # 블랙홀이면 종료 if tmp == -1: return score # 아무 블럭도 없으면 그냥 넘어간다. elif tmp == 0: pass # 1~5번 블록인 경우 점수를 얻고 진입 방향에 맞게 핀볼 진행 방향을 바꿔 준다. elif 1 &lt;= tmp &lt;= 5: score += 1 d = bl[tmp][d] # 웜홀인 경우 다른 웜홀 위치로 좌표를 변경한다. else: x, y = fndh(x, y, tmp) # 진행방향으로 한 칸 이동시킨다. x, y = x + dr[d][0], y + dr[d][1]def fndh(i, j, hn): \"\"\" 입력받은 좌표와 다른 위치에 존재하는 같은 번호를 가진 웜홀의 위치를 반환하는 함수 \"\"\" if [i, j] == bl[hn][0]: return bl[hn][1] else: return bl[hn][0]# 핀볼 진행 방향에 따른 위치 변화dr = [[0, -1], [0, 1], [-1, 0], [1, 0]]# bl[i] (0&lt;i&lt;6): i번째 블록을 특정 방향으로 진입했을 때 바꿔 줄 방향을 기록# bl[i] (i &gt; 5): 웜홀 좌표를 기록bl = [ [0, 0, 0, 0], [1, 3, 0, 2], [3, 0, 1, 2], [2, 0, 3, 1], [1, 2, 3, 0], [1, 0, 3, 2], [], [], [], [], [],]T = int(input())for t in range(1, T+1): N = int(input()) # 입력 주변으로 5번 블록을 추가하여 핀볼 맵을 구성 nl = [[5 for _ in range(N+2)]] for n in range(N): nl.append([5] + list(map(int, input().split())) + [5]) nl.append([5 for _ in range(N+2)]) # 매 테스트케이스마다 웜홀의 위치를 초기화 for i in range(6, 11): bl[i] = [] for i in range(N+2): for j in range(N+2): if nl[j][i] &gt; 5: bl[nl[j][i]].append([i, j])\t# 최고 점수를 계산한 후 출력 print('#{} {}'.format(t, solve()))" }, { "title": "5656. 줄기세포 배양", "url": "/posts/5653-%EC%A4%84%EA%B8%B0%EC%84%B8%ED%8F%AC%EB%B0%B0%EC%96%91/", "categories": "SW Certificate, 모의 SW 역량테스트", "tags": "역량테스트", "date": "2022-08-21 23:30:00 +0900", "snippet": "5653. [모의 SW 역량테스트] 줄기세포 배양문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo강의 링크: https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVvlSPbKAAHw5UPa&amp;subjectId=AWXCKa-KIZYDFAUo문제 접근 방법 줄기 세포는 비활성상태, 활성상태, 사망 세가지 상태가 존재한다. 활성 상태가 된 후 1시간 뒤 세포 복제가 일어난다. 이미 세포가 있는 곳에는 복제가 일어날 수 없다.위 세가지가 문제의 핵심이다.줄기 세포가 분포된 영역의 넓이는 M*N이며 배양 용기의 크기는 무한하다고 주어졌다. 이 경우 배양 용기를 줄기 세포가 최대한 존재할 수 있는 범위로 잡아주거나 해시맵을 활용해서 좌표를 관리해 준다.줄기 세포 분포된 영역이 50 * 50으로 주어졌고 시간이 300일 경우 최악의 경우에도 상 하 좌 우 300 이상 더 증가할 수는 없을 것이다. 배양 용기를 1000 * 1000으로 가정하면 이 범위를 충분히 수용하고 남는다.그렇다면 이 조건으로 메모리가 충분한지 확인해 보자.메모리는 256mb가 주어졌고 각 배양 용기 좌표마다 세포 태어난 시간, 활성화되는 시간, 죽는 시간을 각 각 integer로 담아뒀다고 하면 4byte * 3 * 1000 * 1000 = 12000000byte = 11.4mb이다. 1000 * 1000좌표 각각에 integer 3개씩 담는것은 충분히 수용 가능하다.코드 및 설명풀이 1(1000 * 1000 배열을 이용한 방법)세포의 생명력이 10 이하임을 고려한 접근 방식이다. 세포들이 존재하는 위치를 1000 * 1000 사이즈 nl 배열의 중간쯤에 담아둔다.(입력받은 좌표에 각 각 500씩 더한다.) cells[i]에는 i시간 후 복제되는 세포들의 좌표를 담는다.cells2[i]에는 i시간 후 사망하는 세포들의 갯수를 담을 것이다.(세포가 복제될 때 life 이후 사라지게 됨을 활용) 매 시간마다 아래의 작업을 수행한다. cells[0]의 위치에 존재하는 세포들(0시간 후 복제되는 세포 리스트이므로 지금 복제 시작한다.)을 복제시키면서 life-1시간 후 사망할 세포로 cells2에 카운트 해 준다. 비활성 세포 수 + 활성 세포 수인 cnt 값에 현재 시간에 사망하는 세포 수(cells2[0])만큼 빼 준다. cells와 cells2의 맨 앞의 값을 제거하고 한칸씩 당겨 준다.(i시간 후의 값을 가지고 있는데 시간이 1 지나게 되었으므로) K시간이 지나면 현재 총 살아있는 세포 수 cnt를 출력해준다.D = [[0, 1], [0, -1], [1, 0], [-1, 0]]OFFSET = 500MAP_SIZE = 1000T = int(input())for tc in range(1, T+1): N, M, K = map(int, input().split()) tl = [list(map(int, input().split())) for _ in range(N)] cells = [[] for _ in range(12)] # i 시간 후 복제되는 세포들의 좌표를 담아 둘 리스트 cells2 = [0 for _ in range(12)] # i 시간 후 사망하는 세포 수를 담아 둘 리스트 cnt = 0 # 현재 살아 있는 세포 수(비활성 세포 + 활성 세포) # 세포가 태어난 시간, 활성화되는 시간, 죽는시간 nl = [[[] for _ in range(MAP_SIZE)] for _ in range(MAP_SIZE)]\t# 초기화 for i in range(M): for j in range(N): if tl[j][i]: nl[j+OFFSET][i+OFFSET] = [0, tl[j][i], tl[j][i] &lt;&lt; 1] cells[tl[j][i]].append([i+OFFSET, j+OFFSET]) cnt += 1 turn = 1\t# K 시간동안 활성화, 복제, 사망 수행 while turn &lt;= K: # cells[0]을 본다. 여기에 있는 세포들이 분열한다. for x, y in cells[0]: life = nl[y][x][1] - nl[y][x][0] # 각 세포의 생명력 = 활성화 시간 - 복제된 시간 cells2[life-1] += 1 # 세포 복제를 한 후 현재 세포는 life-1시간 후 사망할 것 for dx, dy in D: tx, ty = x + dx, y + dy\t\t\t\t# 분열할 위치에 이미 세포가 있는 경우 if nl[ty][tx]:\t\t\t\t\t# 만약 이번 시간에 새롭게 분열된 세포이고 가장 수명이 긴 세포로 대체해 준다. if nl[ty][tx][0] == turn and nl[ty][tx][1] - nl[ty][tx][0] &lt; life: nl[ty][tx][1] = turn + life nl[ty][tx][2] = turn + 2 * life else:\t\t\t\t\t# 비어있는 위치에 분열을 시도하는 경우 세포 추가 nl[ty][tx] = [turn, turn + life, turn + 2 * life] cells[life+1].append([tx, ty])\t\t\t\t\t# 살아있는 총 세포 수 추가 cnt += 1\t\t# 이번 분열이 끝난 후 사망할 세포들의 숫자만큼 제거 cnt -= cells2[0]\t\t# 시간이 지났으므로 cells, cells2를 한 개씩 당겨준다. for i in range(11): cells[i], cells[i+1] = cells[i+1], cells[i] cells2[i], cells2[i+1] = cells2[i+1], cells2[i] cells.pop() cells2.pop() cells.append([]) cells2.append(0)\t\t# 실제 시간을 증가시킨다. turn += 1\t\t# 모든 시간이 경과하면 살아 있는 세포 수를 출력해 준다. print(\"#{} {}\".format(tc, cnt))풀이 2(딕셔너리를 활용한 방법)각 세포의 위치를 딕셔너리의 키값으로 사용한다. 세포 정보들을 cells 딕셔너리에 담는다. 매 시간마다 세포들을 확인해서 cells를 최신화한다 복제할 세포들을 확인 네 방향 복제 시작해 임시 세포 딕셔너리에 담기 현재 시간에서 복제가 끝나면 cells 딕셔너리에 임시 세포 딕셔너리 반영 모든 시간이 끝나면 남아있는 세포 중 살아있는 세포들을 세어서 출력def sim(): \"\"\" 매 턴마다 세포들을 확인하여 활성화 되는 시간인 세포들에 대해서 복제를 시도 새롭게 복제된 세포들을 임시 딕셔너리에 담아 둔 후 모든 세포 복제가 끝나면 cells에 반영 \"\"\" temp_cells = dict() for key, value in cells.items(): # 현재 세포가 복제할 세포인 경우 if value[1] + 1 == hour: x, y = map(int, key.split(', ')) # 현재 세포에서 네 방향 확인 for k in range(4): ti, tj = x + D[k][0], y + D[k][1] tmp = ', '.join([str(ti), str(tj)]) # 세포가 비어있는 위치에서 복제 시작 if not cells.get(tmp): # 현재 시간에 복제된 세포가 있는 경우 if temp_cells.get(tmp): # 수명이 긴 세포인 경우 대체 if temp_cells[tmp][0] &lt; value[0]: temp_cells[tmp] = [value[0], hour+value[0], hour+value[0] * 2] # 현재 시간에 복제된 세포가 없는 경우 추가 else: temp_cells[tmp] = [value[0], hour + value[0], hour + value[0] * 2] # 이번 시간에 복제된 세포들을 cells 딕셔너리에 반영 for key, value in temp_cells.items(): cells[key] = valueD = [[0, -1], [0, 1], [-1, 0], [1, 0]]T = int(input())for t in range(1, T+1): N, M, K = map(int, input().split()) nl = [list(map(int, input().split())) for _ in range(N)] # 세포 딕셔너리 생성 cells = dict() # 세포 딕셔너리에 세포들의 정보 입력 for j in range(N): for i in range(M): if nl[j][i]: tmp = nl[j][i] tmp2 = ', '.join([str(i), str(j)]) cells[tmp2] = [tmp, tmp, tmp*2] # 각 시간마다 세포 활성화, 복제, 사망 등 수행 for hour in range(1, K+1): sim() r = 0 # 모든 세포들을 확인하여 살아있는 세포 수 세어서 출력 for key, value in cells.items(): if value[2] &gt; K: r += 1 print('#{} {}'.format(t, r))" }, { "title": "5656. 벽돌 깨기", "url": "/posts/5656-%EB%B2%BD%EB%8F%8C-%EA%B9%A8%EA%B8%B0/", "categories": "SW Certificate, 모의 SW 역량테스트", "tags": "역량테스트", "date": "2022-08-21 21:59:00 +0900", "snippet": "5656. [모의 SW 역량테스트] 벽돌 깨기문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo강의 링크: https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVvlSPbKAAHw5UPa&amp;subjectId=AWXCLPUaIboDFAUo문제 접근 방법 각 벽돌은 구슬에 직접 맞거나 다른 벽돌의 폭파 범위에 있을 경우 터진다. 모든 벽돌의 폭파가 끝난 후 벽돌은 바닥으로 내려간다. 구슬은 최소 1번에서 4번까지 발사될 수 있다.위 세가지가 문제의 핵심이다. 각 구슬이 모든 W에서 발사될 수 있고 N번까지 발사하므로 W^N가지 경우의 수가 나타난다. 최악의 경우 12^4 = 20736가지의 구슬 발사 조합을 살펴보면 된다.구슬 한번 발사에 가장 많이 맵을 탐색하게 되는 경우는 모든 벽돌이 9로 이루어져 있는 너비 12, 높이 15인 맵인 경우이고 이 경우에도 각 블록이 네 방향 다 확인해야한다고 했을 때 36 * 12 * 15 = 6480보다는 작게 확인한다.즉 모든 조합을 다 확인해도 20736 * 6480 = 134369280이다. 이 문제의 경우 제한 시간이 C기준 3초이므로 초당 1억번 정도의 연산을 가정하면 3억번의 연산을 허용하므로 충분히 허용범위 안에 들어간다.따라서 구슬 발사 모든 경우의 수에 대해서 확인해 본다.코드 및 설명 구슬 발사 위치 모든 경우를 perm에서 구한다. 구슬 발사 위치가 정해지면 각 위치에서 구슬을 발사한다. 블록들이 연쇄하며 폭발한다 블록들이 아래로 내려온다 구슬을 모두 발사 한 후 남은 블록의 수를 갱신한다.def crash(i): \"\"\" i 위치에 구슬이 발사된 경우 블록들을 제거한 후 제거된 블록의 갯수를 반환하는 함수. \"\"\" j = fndj(i) # i위치에 가장 높이 있는 블록의 위치를 확인 if j == - 1: # i위치에 블록이 없는 경우 터지는 블록도 0 개이므로 종료한다. return 0 # 구슬이 발사 될 때마다 방문배열이 초기화 되어야 하므로 여기서 방문 배열 선언 vl = [[0 for _ in range(W)] for _ in range(H)] # 구슬에 맞은 블록의 위치를 스택에 담은 후 방문체크 및 터진 블록 카운트에 추가한다. st = [[i, j]] vl[j][i] = 1 cnt = 1 # 구슬 연쇄 폭파 while st: x, y = st.pop() # x, y위치에 존재하는 블록의 숫자만큼 주변을 둘러봐야 한다. for i in range(1, copied_map[y][x]): # 현재 블록에서 i만큼 떨어져 있는 블록들을 확인(네방향) for j in range(4): tx, ty = x + D[j][0] * i, y + D[j][1] * i # tx, ty가 현재 블록에서 i만큼 떨어져 있는 블록의 위치이다. if 0 &lt;= tx &lt; W and 0 &lt;= ty &lt; H: # 맵 안에 존재하는지 우선 확인. if not vl[ty][tx] and copied_map[ty][tx]: # 방문된 적 없고, 블록이 있는 경우에만 아래의 동작을 수행 # 방문여부를 체크해주고 터진 블록 카운트 1, 현재 블록 위치를 스택에 삽입 vl[ty][tx] = 1 cnt += 1 st.append([tx, ty]) # 스택이 비어야 여기에 도달할 수 있다. # 모든 터질 수 있는 블록들이 방문처리 되었음을 의미 # 방문처리된 블록들을 모두 제거한다. for i in range(W): for j in range(H): if vl[j][i]: copied_map[j][i] = 0 # 블록들을 밑으로 끌어내려준다. for i in range(W): tj = H-1 for j in range(H-1, -1, -1): if copied_map[j][i]: copied_map[tj][i], copied_map[j][i] = copied_map[j][i], copied_map[tj][i] tj -= 1 return cntdef perm(dep = 0, bead_index = []): \"\"\" 구슬 N번 발사될 때 구슬이 발사 될 수 있는 모든 경우를 구하는 함수이다. bead_index가 구슬이 발사된 위치를 의미한다. \"\"\" global copied_map, result if result == 0: # 이미 앞의 구슬 발사 위치 조합에서 모든 블록을 다 터트린 경우 더 이상 수행할 필요가 없다. return if dep == N: # 구슬 발사 위치 N개 다 나온 경우 이 위치들에서 구슬을 발사 copied_map = [a[:] for a in nl] cnt = 0 for a in bead_index: cnt += crash(a) if ocnt - cnt &lt; result: result = ocnt - cnt return # 아직 구슬 위치 N개가 안된 경우 구슬 위치를 추가해주는 부분 for i in range(W): bead_index.append(i) perm(dep+1, bead_index) bead_index.pop()def fndj(i): \"\"\" i번 위치에 가장 높은 블록의 높이를 반환하는 함수. \"\"\" for j in range(H): if copied_map[j][i]: return j return -1D = [[0, -1], [0, 1], [-1, 0], [1, 0]]T = int(input())for t in range(1, T+1): N, W, H = map(int, input().split()) nl = [list(map(int, input().split())) for _ in range(H)] ocnt = 0 for i in range(W): for j in range(H): if nl[j][i]: ocnt += 1 copied_map = [] result = H * W perm() print('#{} {}'.format(t, result))" }, { "title": "5658. 보물상자 비밀번호", "url": "/posts/5658-%EB%B3%B4%EB%AC%BC%EC%83%81%EC%9E%90-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8/", "categories": "SW Certificate, 모의 SW 역량테스트", "tags": "역량테스트", "date": "2022-08-21 20:22:00 +0900", "snippet": "5658. [모의 SW 역량테스트] 보물상자 비밀번호문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRUN9KfZ8DFAUo강의 링크: https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVvlSPbKAAHw5UPa&amp;subjectId=AWXCLdcaIdADFAUo문제 접근 방법전체 문자열이 네개의 변에 할당되며 한 칸씩 옆으로 밀면서 가기 때문에 총 한칸씩 옮기는 것을 N/4번 한다면 모든 경우의 수가 찾아진다.N/4번 동안에 각 변의 값들을 모두 구하는데 중복값을 제외해야 한다.중복값을 제거할 경우 set을 사용하면 손쉽게 가능하다.set으로 중복값을 제거한 후 이 요소들을 리스트로 변경하여 정렬을 한 후 K번째로 큰 값을 출력하도록 하면 된다.코드 및 설명각 변의 값에 해당하는 문자열 리스트를 tmp에 담은 뒤 파이썬 기본인 int(’x진수 값 문자열’, x)을 활용하여 integer 값으로 변환하면 된다.int(’F0’, 16)은 16진수 F0을 integer로 변환하라는 의미이며F * 16^1 + 0 * 16^0= 15 * 16 + 0= 240이 된다.int(’x진수 값 문자열’, x) 대신에 반복문을 활용해서 직접 값으로 변환해도 된다.(ord(tmp[i])를 활용하면 계산할 수 있음)위에서 계산한 값을 set에 넣어서 중복을 제거한다.모든 변에 대해서 수행이 끝났으면 set의 요소를 리스트로 변경해주고 정렬한 뒤 K번째로 큰 값을 출력한다.T = int(input())for t in range(1, T+1): N, K = map(int, input().split()) n = N&gt;&gt;2 num = input() value_set = set() for i in range(N): tmp = [] for j in range(n): tmp.append(num[i-n+j+1]) value_set.add(int(''.join(tmp), 16)) value_list = list(value_set) value_list.sort() print('#{} {}'.format(t, value_list[-K]))" }, { "title": "삼성 소프트웨어 역량 테스트", "url": "/posts/SW-%EC%97%AD%EB%9F%89%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "SW Certificate, 일반", "tags": "역량테스트", "date": "2022-07-17 13:32:00 +0900", "snippet": "소프트웨어 역량 테스트란?삼성 내부적으로 운영하는 소프트웨어 역량 인증 평가 시험으로 A형(Advanced), B형(Professional), C형(Expert) 세가지 등급이 존재한다. 코로나 이전에는 상시 시험이 열려 사내 시험이나 공채 코딩테스트 외에도 외부인이 볼 수 있는 방법이 있었지만 지금은 시험 기회가 제한적이다.공채에서의 소프트웨어 역량 테스트역량 인증을 취득하면 채용 프로세스에서 가점이 있기 때문에 만약 SSAFY에서 교육을 받고 있거나 SDS알고리즘 특강 등에 참여하여 시험을 볼 기회를 얻을 수 있다면 역량 인증을 취득하는 것이 유리하다.A형이 있으면 지원 대상이 아닌 예체능 계열도 S직군 지원이 가능해지며, 이외에도 역량 등급에 따라 서류 우대, 코딩테스트 면제, 실무면접 면제 등의 우대를 받을 수 있다.삼성전자에서의 소프트웨어 역량 테스트삼성 그룹에서 소프트웨어 역량 테스트는 삼성전자와 삼성SDS에서 두 곳에서 주최하고 있으며 삼성전자 직원의 경우 삼성전자에서 그 외 그룹사의 경우 삼성SDS에서 주최하는 시험을 응시한다.(Expert는 삼성전자에서만 출제) 두가지 시험은 다 등급은 동일하게 나뉘지만 인정해주는 범위가 다르다.(SDS에서 Professional 취득한것은 전자에서 인정해주지 않는 것으로 알고 있다.)공채에서 S직군을 대상으로 SW 역량테스트를 실시하는데 이것을 통과한 경우(두 문제 중 1문제 이상 해결)에만 면접대상자가 되며, 채용될 경우 사내에서 Advanced 등급을 취득한 것과 동일하게 취급해 준다.만약 S직군으로 지원한 것이 아니었으나 하는 업무가 소프트웨어 개발 관련된 직무인 경우, 사내에서 실시되는 Advanced 시험을 응시하여 취득하면 S직군으로 전환을 할 수도 있다. 사내에서 실시되는 Advanced 시험의 경우 1문제만 출제되며 시험 시간은 3시간이 주어진다.현재 전자 S직군의 경우 B형(Professional)을 취득하는것을 권장받고 있으며 시험 응시하는 시간은 근무한시간으로 인정 및 취득 시 매 월 20만원의 수당이 나온다. (S직군 한정. 수당은 중복 인정되지 않고 가장 높은 것 기준으로 지급되는데 이보다 더 높은 수당을 받고 있는 경우 일시금으로 100만원을 지급받으며 타 직군도 일시금으로 지급받는다.) C형(Expert) 취득 시에는 수당 50만원 혹은 일시금 300만원을 받는 것으로 알고 있다.시험 환경소프트웨어 역량 테스트의 경우 등급별로 사용할 수 있는 언어가 다르다. 등급 C/C++ Java Python A형 ○ ○ ○ B형 ○ ○ △ C형 ○     B형의 경우 Python으로 응시 가능한 시험이 빈번하지는 않지만 열리긴 한다.(약 1개월에 한번정도)C/C++ 개발을 위한 visual studio, Java 개발을 위한 Eclipse, Python 개발을 위한 PyCharm을 제공한다." }, { "title": "SW 역량테스트 Advanced 유형 분석", "url": "/posts/SW-%EC%97%AD%EB%9F%89%ED%85%8C%EC%8A%A4%ED%8A%B8-Advanced-%EC%9C%A0%ED%98%95-%EB%B6%84%EC%84%9D/", "categories": "SW Certificate, Advanced", "tags": "역량테스트, A형", "date": "2022-07-17 13:32:00 +0900", "snippet": "들어가기에 앞서어떤 시험이든 유형을 분석하는 것이 중요하다고 생각합니다. 유형을 알면 내가 부족한 부분이 어떤 부분인지 알게 되고 그것을 보완할 수 있기 때문입니다. 그래서 A형 기출 유형이 어떻게 되고 최근 트렌드가 어떻게 되는지 아는 것이 중요합니다. 그래서 최근 기출 유형을 분석해 보았습니다.기출 유형은 백준을 참고하였습니다.https://www.acmicpc.net/workbook/view/1152https://www.acmicpc.net/workbook/view/2771SW 역량테스트 Advanced 기출 유형 분석아래의 표는 각 기출 문제가 어떤 유형인지 분류해본 것입니다.A형 유사 문제 문제 번호 문제 이름 유형 16637  괄호 추가하기 완전탐색 17070  파이프 옮기기 1 완전탐색/구현 17135  캐슬 디펜스 시뮬레이션/완전탐색/구현 17136  색종이 붙이기 완전탐색/구현 17281  ⚾ 완전탐색/구현 3954  Brainf**k 인터프리터   17406  배열 돌리기 4 구현/순열&amp;조합/배열회전 17471  게리맨더링 bfs&amp;dfs/그래프탐색/완전탐색 17472  다리 만들기 2 mst/bfs&amp;dfs 신입 코테 유사 문제 문제 번호 문제 이름 유형 14502  연구소 구현/bfs&amp;dfs/순열&amp;조합 14503  로봇 청소기 구현/시뮬레이션 14888  연산자 끼워넣기 완전탐색/순열&amp;조합 14889  스타트와 링크 완전탐색/순열&amp;조합 14890  경사로 구현 14891  톱니바퀴 구현/시뮬레이션 15683  감시 구현/순열&amp;조합/완전탐색 15684  사다리 조작 구현/순열&amp;조합/완전탐색 15685  드래곤 커브 구현/시뮬레이션 15686  치킨 배달 구현/순열&amp;조합 5373  큐빙 구현/시뮬레이션 16234  인구 이동 구현/bfs&amp;dfs/시뮬레이션 16235  나무 재테크 구현/시뮬레이션 16236  아기 상어 구현/bfs&amp;dfs/시뮬레이션 17144  미세먼지 안녕! 구현/시뮬레이션 17143  낚시왕 구현/시뮬레이션 17140  이차원 배열과 연산 구현/시뮬레이션 17142  연구소 3 구현/시뮬레이션/bfs&amp;dfs 17779  게리맨더링 2 구현/시뮬레이션/배열좌표계산 17837  새로운 게임 2 구현/시뮬레이션 17822  원판 돌리기 구현/시뮬레이션/bfs&amp;dfs 17825  주사위 윷놀이 구현/순열&amp;조합/시뮬레이션 20061  모노미노도미노 2 구현/시뮬레이션 19236  청소년 상어 구현/시뮬레이션/완전탐색 19237  어른 상어 구현/시뮬레이션 19238  스타트 택시 구현/시뮬레이션 20055  컨베이어 벨트 위의 로봇 구현/시뮬레이션/원형큐 20056  마법사 상어와 파이어볼 구현/시뮬레이션 20057  마법사 상어와 토네이도 구현/시뮬레이션 20058  마법사 상어와 파이어스톰 구현/시뮬레이션/배열회전 21608  상어 초등학교 구현/완전탐색 21609  상어 중학교 구현/배열회전 21610  마법사 상어와 비바라기 구현/시뮬레이션 21611  마법사 상어와 블리자드 구현/시뮬레이션/배열좌표계산 23288  주사위 굴리기 2 구현 23289  온풍기 안녕! 구현/시뮬레이션/bfs&amp;dfs 23290  마법사 상어와 복제 구현/시뮬레이션 23291  어항 정리 구현/시뮬레이션/배열좌표계산 유형 별 출제 횟수 및 트랜드위 표를 참조하여 빈출 유형 및 특징이 어떻게 되는지 정리해 봤습니다. 유형 문항 수 구현/시뮬레이션 72 완전탐색/순열&amp;조합 21 bfs&amp;dfs 8 배열회전/배열좌표계산 6 구현/시뮬레이션: 우선순위 매우 높음. 대부분의 기출 문제가 구현력을 요구하며 구현 지문은 대부분 시뮬레이션을 겸함. 지문에 있는 내용대로 실수없이 구현할 수 있어야 한다. 실수없이 구현하기 위해서는 문제를 많이 풀어 구현력을 키울 필요도 있지만, 코딩을 시작하기 전에 문제 분석을 철저하게 해야 한다. 완전탐색/순열&amp;조합: 우선순위 높음. 모든 경우의 수를 다 따져 봐야 하는 문제들에서 사용되는 개념. bfs&amp;dfs: 우선순위 높음. 문제 해결에 필요한 기본기. bfs/dfs 언급이 없는 문제라 하더라도 이차원 배열 상에서 다른 좌표로 이동하는 방식의 구현이 bfs/dfs와 유사할 수 있으므로 꼭 익숙하게 사용할 줄 알아야한다. 배열회전/배열좌표계산: 최근 문제들에서 자주 보이는 유형. 2차원 배열을 회전, 대각선이동 등 원하는 방식으로 잘 조작할 수 있어야한다. 잘 생각해보면 각 각의 이동에 대해서 계산식을 적용 가능하므로 계산식 기반으로 반복문을 사용하면 실수를 줄일 수 있다. 많은 문제를 풀어볼 필요는 없지만 비슷한 유형의 문제 몇개정도는 경험상 풀어볼 만하다.(우선순위 낮음)" } ]
